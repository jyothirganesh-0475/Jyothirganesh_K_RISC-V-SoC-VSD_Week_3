# 🧠 Post-Synthesis Gate Level Simulation (GLS) — VSDBabySoC
# Table of Contents


1. [Introduction](#-introduction)

2. [What Post-Synthesis (GLS) Actually Does](#what-post-synthesis-gls-actually-does)

3. [Purpose of GLS](#-purpose-of-gls)

4. [High-Level GLS Flow Summary](#-high-level-gls-flow-summary)

5. [Step-by-Step Post-Synthesis Flow](#-step-by-step-post-synthesis-flow)
   1. [Step 1: Load Design Files into Yosys](#-step-1-load-design-files-into-yosys)
   2. [Step 2: Load Liberty Timing Libraries](#-step-2-load-liberty-timing-libraries)
   3. [Step 3: Synthesize the Top Module](#-step-3-synthesize-the-top-module)
   4. [Step 4: Map D Flip-Flops to Standard Cells](#-step-4-map-d-flip-flops-to-standard-cells)
   5. [Step 5: Technology Mapping & Optimization](#-step-5-technology-mapping--optimization)
   6. [Step 6: Final Clean-Up](#-step-6-final-clean-up)
   7. [Step 7: Check Statistics](#-step-7-check-statistics)
   8. [Step 8: Write the Synthesized Netlist](#-step-8-write-the-synthesized-netlist)
   9. [Step 9: Compile Testbench and Netlist](#-step-9-compile-testbench-and-netlist)
   10. [Step 10: Navigate to Output Directory](#-step-10-navigate-to-output-directory)
   11. [Step 11: Run the Simulation](#-step-11-run-the-simulation)
   12. [Step 12: View Waveforms in GTKWave](#-step-12-view-waveforms-in-gtkwave)

6. [Summary Table](#-summary-table)

7. [Result Verification](#-result-verification)

8. [Key Takeaways](#-key-takeaways)

9. [Conclusion](#-conclusion)

---

## 📌 Introduction

Gate-Level Simulation (GLS) is performed **after the synthesis stage** to verify the **functional and timing correctness** of the design at the **gate level**.
Unlike RTL simulation, GLS uses the synthesized **netlist**, which contains actual standard cells and interconnections, giving a more realistic view of how the SoC will behave in silicon.

---

## **What Post-Synthesis (GLS) Actually Does**

1. **Uses Synthesized Netlist**

   * Unlike RTL simulation (which uses abstract behavioral models), GLS simulates the **actual gates** and **connections** generated by synthesis (AND, OR, DFF, etc.).

2. **Verifies Functional Correctness**

   * Ensures that after synthesis, the logic still works as intended.
   * Example: The RISC-V core still executes instructions correctly, clocks propagate as expected, and modules like PLL/DAC behave properly.

3. **Checks Timing Behavior**

   * GLS can include **unit delays** or **SDF delays** to simulate realistic timing.
   * Detects potential **glitches, hazards, or setup/hold violations** that are invisible at RTL.

4. **Detects Post-Synthesis Issues Early**

   * Helps catch problems like:

     * Incorrect flip-flop behavior
     * Clock gating or asynchronous issues

5. **Prepares for STA & Physical Design**

   * GLS confirms that the netlist is **functionally correct**, which is necessary before performing **Static Timing Analysis (STA)** and eventual tapeout.

---



## 🎯 Purpose of GLS

The main purpose of **Post-Synthesis Gate-Level Simulation (GLS)** is to **verify the functionality and timing of this synthesized netlist** before going to physical design (place-and-route).

* ✅ **Timing Verification:** Ensures the design works correctly with real-world timing (through delays from the synthesized netlist or SDF files).
* 🧪 **Functional Check:** Confirms the design still behaves as expected after synthesis mapping.
* 🧭 **Glitch & Metastability Detection:** Detects issues that are not visible in RTL simulation.
* 🧰 **Integration Validation:** Verifies correct interaction between blocks like the RISC-V core, PLL, and DAC in the final netlist.

---


## 🪜 High-Level GLS Flow Summary

#### **1. Perform synthesis of the BabySoC design**

#### **2. Run Gate-Level Simulation (GLS) using the synthesized netlist**

#### **3. Compare GLS output with functional simulation output (Week 2)**
###  **4. ✅ “GLS output matches functional simulation output.”

### 📦 Deliverables

* 📝 `yosys` synthesis logs
* 🖼️ GLS waveform screenshots (`gtkwave`)
* 🧾 A short note confirming:

---

## 📜 Here is the  step wise process for the post-Synthesis (GLS) flow.


## 🪜 Step-by-Step Post-Synthesis Flow

### 🏗️ Step 1: Load Design Files into Yosys

```bash
yosys
```

<img width="1210" height="672" alt="Screenshot from 2025-10-05 11-32-43" src="https://github.com/user-attachments/assets/d0c0e130-5580-4345-a5a6-cb7a355af4d7" />

Inside the Yosys shell:

```tcl
read_verilog /home/jyothirganesh/VLSI/VSDBabySoC/src/module/vsdbabysoc.v
read_verilog -I /home/jyothirganesh/VLSI/VSDBabySoC/src/include /home/jyothirganesh/VLSI/VSDBabySoC/src/module/rvmyth.v
read_verilog -I /home/jyothirganesh/VLSI/VSDBabySoC/src/include /home/jyothirganesh/VLSI/VSDBabySoC/src/module/clk_gate.v
```

📝 **Explanation:**

* `read_verilog` loads Verilog RTL source files.
* `-I` specifies include directories.
* Load the top-level SoC module (`vsdbabysoc`) and supporting modules (RISC-V core and clock gate).


<img width="1725" height="888" alt="Screenshot from 2025-10-11 15-03-17" src="https://github.com/user-attachments/assets/d122e107-eb90-438f-88d9-85c662d5b717" />


---

### 📚 Step 2: Load Liberty Timing Libraries

```tcl
read_liberty -lib /home/jyothirganesh/VLSI/VSDBabySoC/src/lib/avsdpll.lib
read_liberty -lib /home/jyothirganesh/VLSI/VSDBabySoC/src/lib/avsddac.lib
read_liberty -lib /home/jyothirganesh/VLSI/VSDBabySoC/src/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```
📝 **Explanation:**

* Liberty files describe the **timing and power** characteristics of standard cells.
* Yosys uses this information to map RTL logic to physical cells during synthesis.

<img width="1707" height="376" alt="Screenshot from 2025-10-11 15-05-15" src="https://github.com/user-attachments/assets/abebb06b-66bd-4089-92a6-00f3140556e5" />

### 🧭 Step 3: Synthesize the Top Module

```tcl
synth -top vsdbabysoc
```
* Which  Converts RTL design to a technology-independent netlist.
* `-top` specifies the top module to synthesize.                                                   <img width="1216" height="687" alt="Screenshot from 2025-10-05 12-02-27" src="https://github.com/user-attachments/assets/56aa040d-49a3-47cd-9dda-c7fc813330e0" />

<img width="1216" height="687" alt="Screenshot from 2025-10-05 12-09-32" src="https://github.com/user-attachments/assets/316ae4af-b5ab-494c-ba8e-a9cf6a7ab4ac" />

<img width="1209" height="517" alt="Screenshot from 2025-10-05 12-10-44" src="https://github.com/user-attachments/assets/c210b6c3-2294-4e19-8733-8915eb0add79" />

<img width="1214" height="297" alt="Screenshot from 2025-10-05 12-10-57" src="https://github.com/user-attachments/assets/87c459b8-927c-4ca7-97e1-443911cf57dc" />

<img width="1210" height="687" alt="Screenshot from 2025-10-05 12-11-36" src="https://github.com/user-attachments/assets/16fe6dbd-b22b-4dce-84bd-4f20f1ff8de1" />

<img width="1215" height="156" alt="Screenshot from 2025-10-05 12-12-45" src="https://github.com/user-attachments/assets/c4b98205-2ee4-4316-9376-18a7519aab5d" />

---

### ⚡ Step 4: Map D Flip-Flops to Standard Cells

* Maps all generic DFFs to actual **standard cell DFFs** from the Sky130 library.

```tcl
dfflibmap -liberty /home/jyothirganesh/VLSI/VSDBabySoC/src/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```

<img width="1211" height="726" alt="Screenshot from 2025-10-05 12-15-41" src="https://github.com/user-attachments/assets/ed9bfc58-3b3b-457b-b7c6-99e62139de0d" />


---

### 🧠 Step 5: Technology Mapping & Optimization

```tcl
opt
abc -liberty /home/jyothirganesh/VLSI/VSDBabySoC/src/lib/sky130_fd_sc_hd__tt_025C_1v80.lib -script +strash;scorr;ifraig;retime;{D};strash;dch,-f;map,-M,1,{D}
```


* `opt` — performs cleanup and simple optimizations.
* `abc` — maps logic to actual cells and optimizes area and timing.
<img width="1213" height="705" alt="Screenshot from 2025-10-05 12-20-21" src="https://github.com/user-attachments/assets/978db97b-d45b-4426-bbe4-71bc69a7248a" />
<img width="1223" height="387" alt="Screenshot from 2025-10-05 12-20-50" src="https://github.com/user-attachments/assets/8d0ca46c-4b7c-4379-a5ef-732d2cd89ea6" />
<img width="1215" height="686" alt="Screenshot from 2025-10-05 12-23-31" src="https://github.com/user-attachments/assets/8ee76eeb-f500-4a79-9439-69eb02293515" />

---

### 🧹 Step 6: Final Clean-Up

```tcl
flatten
setundef -zero
clean -purge
rename -enumerate
```

📝 **Explanation:**

* `flatten` — flattens hierarchy into a single module.
* `setundef -zero` — removes undefined states by setting them to 0.
* `clean -purge` — deletes unused signals.
* `rename -enumerate` — renames signals systematically.
<img width="1216" height="328" alt="Screenshot from 2025-10-05 12-25-36" src="https://github.com/user-attachments/assets/efb93011-f870-42d0-bdfb-64421d86dbf6" />

---

### 📊 Step 7: Check Statistics

```tcl
stat
```

📝 **Explanation:**

* Displays **number of cells**, area, and design resources after synthesis.
<img width="1217" height="681" alt="Screenshot from 2025-10-05 12-26-14" src="https://github.com/user-attachments/assets/ff7df888-2cc8-417a-80aa-9de0748ce218" />
<img width="1217" height="681" alt="Screenshot from 2025-10-05 12-26-30" src="https://github.com/user-attachments/assets/7da8b1af-bd19-4217-83ff-4fd2f9f3f9d3" />

---

### 💾 Step 8: Write the Synthesized Netlist

```tcl
write_verilog -noattr /home/jyothirganesh/VLSI/VSDBabySoC/src/module/vsdbabysoc.synth.v
```
📝 **Explanation:**

* Writes the **final synthesized netlist** to the specified path.
* `-noattr` removes extra attributes for a clean file.
<img width="1214" height="208" alt="Screenshot from 2025-10-05 12-29-44" src="https://github.com/user-attachments/assets/eea41a5b-b2e5-47c2-b1e5-e2055bd14dcf" />
## Exit from yosys
```tcl
exit
```
---
## Create a directory post_synth_sim in output directorty
```bash
mkdir /home/jyothirganesh/VLSI/VSDBabySoC/output/post_synth_sim
```
* which directory stores the sythesised netlist (.out file) and simulation output (.vcd file)

## 🧪 Post-Synthesis Simulation (GLS)

### 🧰 Step 9: Compile Testbench and Netlist

```bash
iverilog -o /home/jyothirganesh/VLSI/VSDBabySoC/output/post_synth_sim/post_synth_sim.out \
-DPOST_SYNTH_SIM -DFUNCTIONAL -DUNIT_DELAY=#1 \
-I /home/jyothirganesh/VLSI/VSDBabySoC/src/include \
-I /home/jyothirganesh/VLSI/VSDBabySoC/src/module \
-I /home/jyothirganesh/VLSI/VSDBabySoC/src/gls_model \
/home/jyothirganesh/VLSI/VSDBabySoC/src/gls_model/primitives.v \
/home/jyothirganesh/VLSI/VSDBabySoC/src/gls_model/sky130_fd_sc_hd.v \
/home/jyothirganesh/VLSI/VSDBabySoC/src/module/testbench.v
```

📝 **Explanation:**

* `iverilog` — compiles Verilog files for simulation.
* `-DPOST_SYNTH_SIM` — macro for post-synthesis environment.
* `-DFUNCTIONAL` — functional mode without SDF.
* `-DUNIT_DELAY=#1` — unit delays simulate timing behavior.
* Combines testbench and synthesized netlist.
<img width="1217" height="217" alt="Screenshot from 2025-10-07 22-08-52" src="https://github.com/user-attachments/assets/3fcd8014-d87e-41c0-8b34-e87f7e607516" />

---

### 📂 Step 10: Navigate to Output Directory

```bash
cd /home/jyothirganesh/VLSI/VSDBabySoC/output/post_synth_sim/
```
### ▶️ Step 11: Run the Simulation

```bash
./post_synth_sim.out
```

📝 **Explanation:**

* Runs the compiled simulation binary.
* Generates `post_synth_sim.vcd` (waveform file).
<img width="1213" height="132" alt="Screenshot from 2025-10-07 22-15-13" src="https://github.com/user-attachments/assets/d8e3cfad-3f2f-494a-8ea4-e1f707d4c6dd" />

---

### 📈 Step 12: View Waveforms in GTKWave

```bash
gtkwave post_synth_sim.vcd
```

📝 **Explanation:**

* Opens GTKWave to visualize signal transitions at gate level.
* Useful for verifying behavior and timing issues.
<img width="1854" height="1047" alt="Screenshot from 2025-10-08 15-38-23" src="https://github.com/user-attachments/assets/f7d509c5-623e-4ab0-90e1-7d44c87d8de1" />

<img width="1854" height="1047" alt="Screenshot from 2025-10-08 15-38-46" src="https://github.com/user-attachments/assets/c63f2ffe-ca04-4806-a34c-f5ff30d02d8d" />

---

## 🏁 Summary Table

| Stage           | Tool / Command         | Purpose                                |
| --------------- | ---------------------- | -------------------------------------- |
| RTL to Netlist  | `yosys` synthesis flow | Convert RTL to gate-level netlist      |
| Liberty Mapping | `read_liberty`, `abc`  | Use real standard cells                |
| Netlist Export  | `write_verilog`        | Generate `.synth.v`                    |
| GLS             | `iverilog` + `gtkwave` | Post-synthesis functional verification |

---

## 🧾 Result Verification

This section confirms that the **Gate-Level Simulation (GLS)** output matches the **Week 2 functional simulation output**.
The foolowing wave form is **week 2 functional simlation output** i.e **pre_synth_out**
<img width="1213" height="776" alt="image" src="https://github.com/user-attachments/assets/2d9b83e9-af32-46cc-97b9-3a40723c687e" />

<img width="1203" height="563" alt="image" src="https://github.com/user-attachments/assets/deff8c4c-ba34-4a14-be23-11241a5a4d82" />


* ✅ GLS waveform matches the functional simulation output.
* Key signals verified: **clock**, **reset**, and **RISC-V core outputs**.
* No glitches, hazards, or functional mismatches observed.

**✔️ GLS = Functional Outputs Confirmed**

---

## 🧠 Key Takeaways

* ✅ GLS verifies functionality **after** synthesis with real cell delays.
* ⏱️ Helps detect glitches, hazards, and integration issues early.
* 🧰 A crucial step before physical design (P&R) and tapeout.
* 📊 Can be extended with SDF for more accurate delay simulation.

---

## 🏁 Conclusion

* The **Post-Synthesis Gate-Level Simulation (GLS)** of VSDBabySoC was successfully completed.
* GLS results were **verified against the Week 2 functional simulation**, and all outputs matched.
* The flow demonstrates the importance of **synthesized netlist verification** before physical design and STA.
* This task provided hands-on experience with **Yosys synthesis**, **Icarus Verilog simulation**, and **GTKWave waveform analysis**, forming a solid foundation for **Static Timing Analysis (STA)** in subsequent tasks.

---
